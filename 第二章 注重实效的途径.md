系统的每一项知识都必须具有单一，无歧义，权威的表示 DRY

重复的发生： 加强重复，无意识重复，无耐心重复， 开发者之间的重复

    加强重复
        通过使用简单的代码生成器，根据公共数据构建冗余结构

        代码要与文档同时变更

        语言问题没有很好的处理方案，最好是接口与实现分离

    无意识重复
        即时某些地方因为性能原因违反dry原则，也需要将该影响局部化，外部不应该感知该行为

    无耐心重复
        现在可能节省几秒钟，但是之后会付出代价

    开发者之间的重复
        通过强有力的项目领导以及在项目中有明确的责任划分来处理

        鼓励程序员的交流
    
正交性： 对于到编程属于相当于解耦性
    提升效率： 改动得以局部化， 促进复用， 促进组合
    降低风险： 有问题的代码被隔离， 系统更健壮， 能得到更好的测试， 不和特定平台绑定

    通过模块划分，功能划分使得团队成员间的正交性增强

    设计： 正交设计分为多个层级或模块，每层提供自己的抽象。当显著的修改某个特定功能时，应该只有一个模块收到影响

    工具箱与库： 引入第三方库的时候，要明智的选择库，尽量保持原有的正交性

    编码： 
        让你的代码保持解耦
        避免使用全局数据
        避免编写相似函数

    测试： 构建测试样例的时候，考虑是否是引入了系统的其他模块，如果是，你发现了正交问题。同样你也可以在修改bug的时候发现问题

可撤销性
    如果只有一个想法，那这是危险的。没什么是永远不变的，如果你严重依赖某个事实， 你几乎可以确定，它将会变化

    需要有灵活的架构

    不存在最终决策

曳光弹
    我们需要能让我们 快速直观可重复的从需求出发，最终满足系统的某个方面

    优点： 能够让用户及早看到能工作的东西， 开发者构建了一个他们能够在其中工作的结构， 你有了一个集成平台， 你有了可以用于演示的代码， 你将更能感觉工作进展

    原型制作和曳光弹的区别： 原型是用过就扔的代码， 而曳光代码是最终骨架的一部分


原型与便签
    原型为我们分析和揭示风险，并大大降低代价。原型制作是一种学习经验，其价值并不在于其所生产的代码，而是所学习的经验和教训

    应忽略哪些细节： 正确性，完整性，健壮性， 风格
    原型是为何了解系统怎样结合成一个整体
    你可以在架构原型中解答以下问题：
        主要组件的责任是否得到定义
        主要组件的协议是否得到定义
        耦合是否最小化
        能否确定重复的潜在来源
        接口定义和约束是否可接受
        原型能否获取自己所需的数据

领域语言

    无论是哪种语言，你都应该考虑让项目更靠近问题领域，通过高级别的抽象层的编码， 你获得了专心解决领域问题的自由

实现小型语言
    可以采用易于解析的格式

数据语言与命令语言
    数据语言通常用来表示配置信息， 命令语言被实际执行。

易于开发还是易于维护
    解析语言可能很难编写但语言本省却更仍以被人理解， 有很多语言容易解析，但是却晦涩难懂


    todo: 了解BNF是什么， 如何定义文法

估算
    估算可以避免发生意外

    1. 要考虑语境，才知道多精确才够精确 180天左右和6个月左右完全不同。
    2. 估算以问题为模型， 有个诀窍： 先问已经做过这件事的人
    3. 理解问题内容，做出问题域的假设
    4. 建立模型系统也是要引入不精确性的
    5. 将模型分解为组件，每个组件都有若干参数
    6. 给每个参数指定值， 你要找出哪些参数对结果的影响最大， 并保证他们大致正确
    7. 计算答案
    8. 追踪估算能力， 考虑下事情与猜想并不相同的原因
    9. 通过代码对进度表进行迭代
    10. 在被估算的时候放慢估算的速度